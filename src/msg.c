/*
   This file is part of braid <https://huntprod.com/s/braid>
   Copyright 2018 Hunt Productions, Inc.

   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons to whom the Software is furnished to do so, subject to the
   following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
   msg.c - HTTP Message Parsing and Introspection functions
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* define the http_is_* character class predicates, as
   generated by our "macro" table processor, gen/tables */
#include "msg.tbl.inc"

#define new(t) (malloc(sizeof(t)))

struct http_header {
	const char         *name;   /* header name, i.e. 'Host:', as a pointer
	                               into the 'raw' buffer. */
	const char         *value;  /* header value, as a pointer into 'raw'. */
	struct http_header *next;   /* next node in singly-linked list. */
	char                raw[];  /* contains the header and value. */
};

static struct http_header * header_literal(const char *name, const char *value);
static struct http_header * free_header(struct http_header *header);
static struct http_header * push_header(struct http_header *add, struct http_header *list);

/* known HTTP protocol versions */
#define HTTP_V0_9 9
#define HTTP_V1_0 10
#define HTTP_V1_1 11
#define HTTP_V2   20

struct http_request {
	/* request-line (a start-line) */
	int   req_protocol; /* version of the protocol; an HTTP_V* flag */
	char *req_method;   /* method token, e.g. "GET", "POST", etc. */
	char *req_uri;      /* requested URI */

	/* request headers */
	struct http_header *headers;
};

#define PBUFSIZ 8192
#define PFSM_REQ_METHOD  0
#define PFSM_REQ_TARGET  1
#define PFSM_REQ_VERSION 2
#define PFSM_HEADER      3
#define PFSM_BODY        4
#define P_BAD_REQUEST    400
struct parser {
	int  flags;
	int  dot;
	int  used;
	int  fd;
	char buf[PBUFSIZ];

	int state;
	struct http_request *req;
};

static char * extract(const char *a, const char *b);
static int advance(struct parser *p);

static char *
extract(const char *a, const char *b)
{
	char *x;

	x = malloc(sizeof(char) * (b - a + 1));
	if (!x) return NULL;

	memcpy(x, a, b - a);
	x[b - a] = '\0';
	return x;
}

static int
advance(struct parser *p)
{
	char *anchor, *c, *end;
	ssize_t nread;

	nread = read(p->fd,
	             p->buf + p->used,
	             PBUFSIZ - p->used);

	if (nread < 0)
		return -1;

	p->used += nread;
	if (p->used == 0)
		return -1;

	end = p->buf + p->used;
	c = p->buf + p->dot;

again:
	switch (p->state) {
	case PFSM_REQ_METHOD:
		/* eat TOKEN chars until we hit SP. */
		anchor = c;
		if (!http_is_token(*c))
			goto bad_request;
		while (c < end && http_is_token(*c))
			c++;
		if (c == end)         goto incomplete;
		if (!http_is_sp(*c))  goto bad_request;
		p->req->req_method = extract(anchor, c);
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_REQ_TARGET;
		/* fallthrough */

	case PFSM_REQ_TARGET:
		/* eat !SP chars until we hit SP. */
		anchor = c;
		while (c < end && !http_is_sp(*c))
			c++;
		if (c == end) goto incomplete;
		/* FIXME: doesn't handl request URI > PBUFSIZ */
		p->req->req_uri = extract(anchor, c);
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_REQ_VERSION;
		/* fallthrough */

	case PFSM_REQ_VERSION:
		anchor = c;
		if ( *c != 'H') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'T') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'T') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'P') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != '/') goto bad_request;
		if (++c == end) goto incomplete;

		switch (*c) {
		default:             goto bad_request;
		case '0':
			if ( *c != '.')  goto bad_request;
			if (++c == end)  goto incomplete;
			switch (*c) {
			default:         goto bad_request;
			case '9':
				p->req->req_protocol = HTTP_V0_9;
				break;
			}
			break;
		case '1':
			if ( *c != '.')  goto bad_request;
			if (++c == end)  goto incomplete;
			switch (*c) {
			default:         goto bad_request;
			case '0':
				p->req->req_protocol = HTTP_V1_0;
				break;
			case '1':
				p->req->req_protocol = HTTP_V1_1;
				break;
			}
			break;
		case '2':
			p->req->req_protocol = HTTP_V2;
			break;
		}
		if (++c == end)      goto incomplete;
		if (!http_is_cr(*c)) goto bad_request;
		if (++c == end)      goto incomplete;
		if (!http_is_lf(*c)) goto bad_request;
		p->dot = c - p->buf;
		p->state = PFSM_HEADER;
		/* fallthrough */

	case PFSM_HEADER:
		if (http_is_cr(*c)) {
			if (++c == end)      goto incomplete;
			if (!http_is_lf(*c)) goto bad_request;
			c += 1;
			p->dot = c - p->buf;
			p->state = PFSM_BODY;
			goto again;
		}
		if (!http_is_token(*c)) goto bad_request;
		while (c < end && http_is_token(*c))
			c++;
		if (c == end)     goto incomplete;
		if (*c++ != ':')  goto bad_request;
header_value:
		while (c < end && http_is_wsp(*c))
			c++;
		if (c == end) goto incomplete;
		anchor = c;
		while (c < end && !http_is_cr(*c))
			c++;
		if (c == end) goto incomplete;
		if (!http_is_cr(*c)) goto bad_request;
		if (++c == end)      goto incomplete;
		if (!http_is_lf(*c)) goto bad_request;
		if (++c == end)      goto incomplete;
		if (http_is_wsp(*c)) goto header_value;
		fprintf(stderr, "found a header value [%s].\n", anchor);
		p->dot = c - p->buf;
		goto again;

	case PFSM_BODY:
		fprintf(stderr, "found body: [%s]\n", c);
		break;
	}

	return 0;

incomplete:
	return 0; /* FIXME: if we EOF'd... */

bad_request:
	p->flags = P_BAD_REQUEST;
	return -1;
}

static struct http_request * parse_request(FILE *in);
static void print_request(FILE *out, struct http_request *req);
static void free_request(struct http_request *req);

static struct http_request * parse_request(FILE *in)
{
	struct http_request *req;
	char *p, *try, *end, buf[8192];

	if (fgets(buf, 8192, in) == NULL)
		return NULL;
	end = strchr(buf, '\n');
	if (end) end = end + 1;
	else     end = buf + (sizeof(buf) / sizeof(buf[0]));

	req = new(struct http_request);
	fprintf(stderr, "debug: read line [%s]\n", buf);

	/* parse the start-line:
	     method SP request-target SP HTTP-version CRLF
	 */
	req->req_method = try = p = buf;
	if (!http_is_token(*p)) {
		fprintf(stderr, "BAD REQUEST: request line starts with non-token char [%s].\n", try);
		free(req);
		return NULL;
	}
	while (p < end && http_is_token(*p))
		p++;

	if (p == end) {
		fprintf(stderr, "BAD REQUEST: short start-line (EOF / EOB found during or immediately after method.\n");
		free(req);
		return NULL;
	}

	if (!http_is_sp(*p)) {
		fprintf(stderr, "BAD REQUEST: first non-token char after method is not a SP.\n");
		free(req);
		return NULL;
	}
	*p++ = '\0';

	req->req_uri = try = p;
	while (p < end && !http_is_sp(*p))
		p++;

	if (p == end) {
		fprintf(stderr, "BAD REQUEST: short start-line (EOF / EOB found during or immediately after request-target [%s].\n", try);
		free(req);
		return NULL;
	}

	if (!http_is_sp(*p)) {
		fprintf(stderr, "BAD REQUEST: first non-token char after request-target is not a SP (in [%s]).\n", try);
		free(req);
		return NULL;
	}
	*p++ = '\0';

	try = p;
	if (*p++ != 'H' || p >= end ||
	    *p++ != 'T' || p >= end ||
	    *p++ != 'T' || p >= end ||
	    *p++ != 'P' || p >= end ||
	    *p++ != '/' || p >= end) {

		fprintf(stderr, "BAD REQUEST: HTTP protocol version (%s) not recognized [1].\n", try);
		free(req);
		return NULL;
	}
	if (*p == '0' && ++p < end) {
		if (*p++ != '.' || p >= end ||
		    *p++ != '9' || p >= end) {

			fprintf(stderr, "BAD REQUEST: HTTP protocol version (%s) not recognized [2].\n", try);
			free(req);
			return NULL;
		}
		req->req_protocol = HTTP_V0_9;

	} else if (*p == '1' && ++p < end) {
		if (*p++ != '.' || p >= end) {
			fprintf(stderr, "BAD REQUEST: HTTP protocol version (%s) not recognized [3].\n", try);
			free(req);
			return NULL;
		}
		switch (*p++) {
		case '0': req->req_protocol = HTTP_V1_0; break;
		case '1': req->req_protocol = HTTP_V1_1; break;
		default:
			fprintf(stderr, "BAD REQUEST: HTTP protocol version (%s) not recognized [4].\n", try);
			free(req);
			return NULL;
		}

	} else if (*p == '2') {
		p++;
		req->req_protocol = HTTP_V2;
	}

	if (                     p >= end ||
	    !http_is_cr(*p) || ++p >= end ||
	    !http_is_lf(*p) || ++p != end) {
		fprintf(stderr, "BAD REQUEST: HTTP protocol version (%s) not recognized [5].\n", try);
		free(req);
		return NULL;
	}

	fprintf(stderr, "METHOD: [%s]\n", req->req_method);
	fprintf(stderr, "TARGET: [%s]\n", req->req_uri);

	/* parse the headers */
	for (;;) {
		if (fgets(buf, 8192, in) == NULL)
			break;

		end = strchr(buf, '\n');
		if (end) end = end + 1;
		else     end = buf + (sizeof(buf) / sizeof(buf[0]));
		fprintf(stderr, "debug: read line [%s]\n", buf);

		try = p = buf;
		if (http_is_cr(*p) && ++p < end && http_is_lf(*p)) {
			p++;
			break;
		}
		if (!http_is_token(*p)) {
			fprintf(stderr, "BAD REQUEST: header does not start with a token char [%s].\n", try);
			free(req);
			return NULL;
		}
		while (p < end && http_is_token(*p))
			p++;
		if (p == end) {
			fprintf(stderr, "BAD REQUEST: header ends prematurely (before ':').\n");
			free(req);
			return NULL;
		}
		if (*p != ':') {
			fprintf(stderr, "BAD REQUEST: header not immediately followed by ':' delimiter.\n");
			free(req);
			return NULL;
		}
		*p++ = '\0';

		fprintf(stderr, "FOUND HEADER {%s}\n", try);
		while (p < end && http_is_wsp(*p))
			p++;
		if (p == end) {
			fprintf(stderr, "BAD REQUEST: no value given for header.\n");
			free(req);
			return NULL;
		}

continuation:
		try = p;
		while (p < end && !http_is_cr(*p))
			p++;
		if (p == end) {
			fprintf(stderr, "BAD REQUEST: end of buffer found before terminating CR.\n");
			free(req);
			return NULL;
		}
		*p++ = '\0';
		if (p == end || !http_is_lf(*p)) {
			fprintf(stderr, "BAD REQUEST: missing LF after CR after header value.\n");
			free(req);
			return NULL;
		}
		fprintf(stderr, "FOUND VALUE  [%s]\n", try);
		if (http_is_wsp(*p)) {
			while (p < end && http_is_wsp(*p))
				p++;
			fprintf(stderr, "!! CONTINUATION FOUND!\n");
			goto continuation;
		}
	}

	return req;
}

static void print_request(FILE *out, struct http_request *req)
{
	fprintf(out, "--[ request ]------\n");
	fprintf(out, "\n");
}

static void free_request(struct http_request *req)
{
	free(req);
}

void tests() {
	const char *valid;
	unsigned char c;
	int ok = 1;

	/* token tests */
	valid = "!#$%&'*+-.^_`|~";
	for (c = 0; c < 0xff; c++) {
		if ((c && strchr(valid, c)) || (c >= 'a' && c <= 'z')  ||
		    (c >= 'A' && c <= 'Z')  || (c >= '0' && c <= '9')) {
			if (!http_is_token(c)) {
				ok = 0;
				fprintf(stderr, "FAIL. '%c' (%#02x) should be a token character, but isn't.\n", c, c);
			}
		} else {
			if (http_is_token(c)) {
				ok = 0;
				fprintf(stderr, "FAIL. '%c' (%#02x) shouldn't be a token character, but is.\n", c, c);
			}
		}
	}
}

int main(int argc, char **argv)
{
	struct parser parser;
	struct http_request *req;
	tests();

	memset(&parser, 0, sizeof(parser));
	parser.fd = 0;
	advance(&parser);

	req = parse_request(stdin);
	print_request(stdout, req);
	free_request(req);
	return 0;
}
