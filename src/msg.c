/*
   This file is part of braid <https://huntprod.com/s/braid>
   Copyright 2018 Hunt Productions, Inc.

   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons to whom the Software is furnished to do so, subject to the
   following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
   msg.c - HTTP Message Parsing and Introspection functions
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* define the http_is_* character class predicates, as
   generated by our "macro" table processor, gen/tables */
#include "msg.tbl.inc"

#define new(t) (calloc(1, sizeof(t)))

struct http_header {
	char  *name;
	char  *value;

	struct http_header *next;
};

/* known HTTP protocol versions */
#define HTTP_V0_9 9
#define HTTP_V1_0 10
#define HTTP_V1_1 11
#define HTTP_V2   20

struct http_request {
	/* request-line (a start-line) */
	int   req_protocol; /* version of the protocol; an HTTP_V* flag */
	char *req_method;   /* method token, e.g. "GET", "POST", etc. */
	char *req_uri;      /* requested URI */

	/* request headers */
	struct http_header *headers;
};

struct strand {
	size_t         len;
	char          *data;
	struct strand *next;
};

static char * string(struct strand *st);
static struct strand * append(struct strand *st, const char *a, const char *b);
static struct strand * appendc(struct strand *st, char c);

static char *
string(struct strand *st)
{
	char *s;
	size_t i, len;
	struct strand *tmp;

	if (!st)
		return NULL;

	if (st && !st->next) {
		s = st->data;
		free(st);
		return s;
	}

	len = 0;
	for (tmp = st; tmp; tmp = tmp->next)
		len += tmp->len;

	s = malloc(sizeof(char) * (len + 1));
	if (!s)
		return NULL;

	i = 0; tmp = st;
	while (tmp) {
		memcpy(s+i, tmp->data, tmp->len);
		i += tmp->len;
		st = tmp->next;
		free(tmp);
		tmp = st;
	}
	assert(i == len);
	s[i] = '\0';
	return s;
}

static struct strand *
append(struct strand *st, const char *a, const char *b)
{
	struct strand *ins;

	if (!st) {
		st = ins = new(struct strand);

	} else {
		for (ins = st; ins->next; ins = ins->next)
			;
		ins->next = new(struct strand);
		ins = ins->next;
	}

	if (!ins)
		return NULL;

	ins->len = b - a;
	ins->data = malloc(sizeof(char) * ins->len);
	memcpy(ins->data, a, ins->len);
	return st;
}

static struct strand *
appendc(struct strand *st, char c)
{
	char buf[2] = {c, '\0'};
	return append(st, buf, buf+1);
}

#define PBUFSIZ 1024
#define PFSM_REQ_METHOD   0
#define PFSM_REQ_TARGET   1
#define PFSM_REQ_VERSION  2
#define PFSM_HEADER_NAME  3
#define PFSM_HEADER_VALUE 4
#define PFSM_BODY         5
#define P_BAD_REQUEST    400
#define P_INTERNAL_ERROR 500
struct parser {
	int  flags;
	int  dot;
	int  used;
	int  fd;
	char buf[PBUFSIZ];
	struct strand *strand;

	int state;
	struct http_request *req;
	struct http_header *header;
};

static char * extract(const char *a, const char *b);
static int advance(struct parser *p);

static char *
extract(const char *a, const char *b)
{
	char *x;

	x = malloc(sizeof(char) * (b - a + 1));
	if (!x) return NULL;

	memcpy(x, a, b - a);

	x[b - a] = '\0';
	return x;
}

static int
advance(struct parser *p)
{
	char *anchor, *c, *end;
	ssize_t nread;

	/* initialization, in case it hasn't been done before */
	if (!p->req)
		p->req = new(struct http_request);
	if (!p->req)
		return -1;

reread:
	nread = read(p->fd,
	             p->buf + p->used,
	             PBUFSIZ - p->used);

	if (nread < 0)
		return -1;

	p->used += nread;
	if (p->used == 0)
		return -1;
	p->buf[p->used] = '\0';

	end = p->buf + p->used;
	c = p->buf + p->dot;

again:
	switch (p->state) {
	case PFSM_REQ_METHOD:
		/* eat TOKEN chars until we hit SP. */
		anchor = c;
		if (!http_is_token(*c))
			goto bad_request;
		while (c < end && http_is_token(*c))
			c++;
		if (c == end)         goto incomplete;
		if (!http_is_sp(*c))  goto bad_request;
		p->req->req_method = extract(anchor, c);
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_REQ_TARGET;
		/* fallthrough */

	case PFSM_REQ_TARGET:
		/* eat !SP chars until we hit SP. */
		anchor = c;
		while (c < end && !http_is_sp(*c))
			c++;
		p->strand = append(p->strand, anchor, c);
		if (c == end)
			goto slide;
		p->req->req_uri = string(p->strand);
		p->strand = NULL;
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_REQ_VERSION;
		/* fallthrough */

	case PFSM_REQ_VERSION:
		anchor = c;
		if ( *c != 'H') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'T') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'T') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != 'P') goto bad_request;
		if (++c == end) goto incomplete;
		if ( *c != '/') goto bad_request;
		if (++c == end) goto incomplete;

		switch (*c) {
		default:             goto bad_request;
		case '0':
			if (++c == end)  goto incomplete;
			if ( *c != '.')  goto bad_request;
			if (++c == end)  goto incomplete;
			switch (*c) {
			default:         goto bad_request;
			case '9':
				p->req->req_protocol = HTTP_V0_9;
				break;
			}
			break;
		case '1':
			if (++c == end)  goto incomplete;
			if ( *c != '.')  goto bad_request;
			if (++c == end)  goto incomplete;
			switch (*c) {
			default:         goto bad_request;
			case '0':
				p->req->req_protocol = HTTP_V1_0;
				break;
			case '1':
				p->req->req_protocol = HTTP_V1_1;
				break;
			}
			break;
		case '2':
			p->req->req_protocol = HTTP_V2;
			break;
		}
		if (++c == end)      goto incomplete;
		if (!http_is_cr(*c)) goto bad_request;
		if (++c == end)      goto incomplete;
		if (!http_is_lf(*c)) goto bad_request;
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_HEADER_NAME;
		/* fallthrough */

	case PFSM_HEADER_NAME:
		anchor = p->buf + p->dot;
		if (http_is_cr(*c)) {
			if (++c == end)      goto incomplete;
			if (!http_is_lf(*c)) goto bad_request;
			c += 1;
			p->dot = c - p->buf;
			p->state = PFSM_BODY;
			goto again;
		}
		if (!http_is_token(*c)) goto bad_request;
		while (c < end && http_is_token(*c))
			c++;
		p->strand = append(p->strand, anchor, c);
		if (c == end)
			goto slide;
		if (*c != ':') goto bad_request;
		p->header = new(struct http_header);
		p->header->next = p->req->headers;
		p->req->headers = p->header;
		p->header->name = string(p->strand);
		p->strand = NULL;
		c += 1;
		p->dot = c - p->buf;
		p->state = PFSM_HEADER_VALUE;
		/* fallthrough */

	case PFSM_HEADER_VALUE:
header_value:
		while (c < end && http_is_wsp(*c))
			c++;
		if (c == end) goto hold;
		anchor = c;
		while (c < end && !http_is_cr(*c))
			c++;
		if (c == end)        goto hold;
		if (!http_is_cr(*c)) goto bad_request;
		p->strand = append(p->strand, anchor, c);
		if (++c == end)      goto incomplete;
		if (!http_is_lf(*c)) goto bad_request;
		if (++c == end)      goto incomplete;
		if (http_is_wsp(*c)) {
			p->strand = appendc(p->strand, ' ');
			goto header_value;
		}
		p->header->value = string(p->strand);
		p->strand = NULL;
		p->dot = c - p->buf;
		p->state = PFSM_HEADER_NAME;
		goto again;

	case PFSM_BODY:
		break;
	}

	return 0;

hold:
	p->strand = append(p->strand, anchor, c);
slide:
	fprintf(stderr, "... and we're out of bytes.  sliding the buffer.\n");
	p->used = p->dot = 0;
	goto reread;

incomplete:
	fprintf(stderr, "... and we're out of bytes.\n");
	return 0; /* FIXME: if we EOF'd... */

bad_request:
	fprintf(stderr, "oops, triggering a BAD_REQUEST...\n");
	p->flags = P_BAD_REQUEST;
	return -1;

internal_error:
	fprintf(stderr, "oops, triggering an INTERNAL_ERROR...\n");
	p->flags = P_INTERNAL_ERROR;
	return -1;
}

static void print_request(FILE *out, struct http_request *req);
static void free_request(struct http_request *req);

static void print_request(FILE *out, struct http_request *req)
{
	struct http_header *header, *next, *prev;

	fprintf(out, "--[ request ]------\n");
	fprintf(out, "%s %s HTTP/", req->req_method, req->req_uri);
	switch (req->req_protocol) {
	case HTTP_V0_9: fprintf(out, "0.9\n"); break;
	case HTTP_V1_0: fprintf(out, "1.0\n"); break;
	case HTTP_V1_1: fprintf(out, "1.1\n"); break;
	case HTTP_V2:   fprintf(out, "2\n");   break;
	}

	for (next = prev = NULL, header = req->headers;
	     header != NULL;
	     next = header->next, header->next = prev,
	     prev = header, header = next);
	req->headers = prev;

	for (header = req->headers; header; header = header->next)
		fprintf(out, "%s: %s\n", header->name, header->value);
	fprintf(out, "\n");
}

static void free_request(struct http_request *req)
{
	free(req);
}

void tests() {
	const char *valid;
	unsigned char c;
	int ok = 1;

	/* token tests */
	valid = "!#$%&'*+-.^_`|~";
	for (c = 0; c < 0xff; c++) {
		if ((c && strchr(valid, c)) || (c >= 'a' && c <= 'z')  ||
		    (c >= 'A' && c <= 'Z')  || (c >= '0' && c <= '9')) {
			if (!http_is_token(c)) {
				ok = 0;
				fprintf(stderr, "FAIL. '%c' (%#02x) should be a token character, but isn't.\n", c, c);
			}
		} else {
			if (http_is_token(c)) {
				ok = 0;
				fprintf(stderr, "FAIL. '%c' (%#02x) shouldn't be a token character, but is.\n", c, c);
			}
		}
	}
}

int main(int argc, char **argv)
{
	struct parser parser;
	struct http_request *req;
	tests();

	memset(&parser, 0, sizeof(parser));
	parser.fd = 0;
	advance(&parser);
	print_request(stdout, parser.req);
	free_request(req);
	return 0;
}
